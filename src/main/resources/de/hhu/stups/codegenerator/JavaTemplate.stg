keywords() ::= <<
abstract, assert, boolean, break, byte, case, catch, char, class, continue, default, do, double, else, enum, extends, final, finally, float, for, if, implements, import, instanceof, int, interface, long, native, new, package, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, try, void, volatile, while, true, false, null, var, const, goto, initialized, initialize
>>


machine(imports, machine, constants_declarations, constants_initializations, values, includes, enums, sets, declarations, initialization, operations, addition) ::= <<
<imports; separator="\n">
import de.hhu.stups.btypes.BUtils;

public class <machine> {

    <constants_declarations; separator="\n">

    static {
        <constants_initializations; separator="\n">
    }

    <values>

    <includes; separator="\n">

    <enums; separator="\n\n">

    <sets; separator="\n">

    <declarations; separator="\n">

    <initialization>

    <operations; separator="\n\n">


    <addition>

}

>>

initialization(machine, body) ::= <<
public <machine>() {
    <body>
}
>>

method() ::= <<
>>

operation(returnType, operationName, parameters, locals, body, return) ::= <<
public <returnType> <operationName>(<parameters; separator=", ">) {
    <locals; separator="\n">
    <body>
    <return>
}
>>

return(identifier) ::= <<
return <identifier>;
>>

no_return() ::=<<
>>

set_declaration(identifier, type, enums) ::= <<
private BSet\<<type>\> <identifier> = <set_enumeration(enums, false)>;
>>

set_enumeration(enums, isRelation) ::= <<
<if(isRelation)>new BRelation\<><else>new BSet\<><endif>(<enums; separator=", ">)
>>

set_comprehension(type, identifier, isRelation, otherIterationConstructs, comprehension) ::= <<
<type> <identifier> = new <if(isRelation)>BRelation<else>BSet<endif>\<>();
<otherIterationConstructs>
<comprehension>
>>

iteration_construct_enumeration(type, identifier, set, body) ::= <<
for(<type> <identifier> : <set>) {
    <body>
}
>>

iteration_construct_assignment(type, identifier, expression, body) ::= <<
<type> <identifier> = <expression>;
<body>
>>

iteration_construct_subset(type, identifier, set, body) ::= <<
for(<type> <identifier> : <set>.pow()) {
    <body>
}
>>

iteration_construct_subsetneq(type, identifier, set, body) ::= <<
for(<type> <identifier> : <set>.pow().difference(<set>)) {
    <body>
}
>>

set_comprehension_predicate(set, element, predicate) ::= <<
if((<predicate>).booleanValue()) {
    <set> = <set>.union(new BSet\<>(<element>));
}
>>

lambda(type, identifier, otherIterationConstructs, lambda) ::= <<
<type> <identifier> = new BRelation\<>();
<otherIterationConstructs>
<lambda>
>>

lambda_expression(relation, element, expression, predicate) ::= <<
if((<predicate>).booleanValue()) {
    <relation> = <relation>.union(new BRelation\<>(new BCouple\<>(<element>, <expression>)));
}
>>

quantified_predicate(identifier, forall, otherIterationConstructs, predicate) ::= <<
BBoolean <identifier> = new BBoolean(<if(forall)>true<else>false<endif>);
<otherIterationConstructs>
<predicate>
>>

quantified_evaluation(identifier, predicate, forall) ::= <<
if(<if(forall)>!<endif>(<predicate>).booleanValue()) {
    <identifier> = new BBoolean(<if(forall)>false<else>true<endif>);
    break;
}
>>

enum_call(class, identifier) ::= <<
<class>.<identifier>
>>

set_enum_declaration(name,enums) ::= <<
public enum <name> implements BObject {
    <enums; separator=", \n">;

    public BBoolean equal(<name> o) {
        return new BBoolean(this == o);
    }

    public BBoolean unequal(<name> o) {
        return new BBoolean(this != o);
    }
}
>>

bool() ::= <<
BUtils.BOOL
>>

include_declaration(type, identifier) ::= <<
private <declaration(type, identifier)> = new <type>();
>>

global_declaration(type, identifier) ::= <<
private <declaration(type, identifier)>;
>>

local_declaration(type, identifier) ::= <<
<declaration(type, identifier)> = null;
>>

constant_declaration(type, identifier) ::= <<
private static final <type> <identifier>;
>>

constant_initialization(iterationConstruct, identifier, val) ::= <<
<iterationConstruct; separator="\n">
<identifier> = <val>;
>>

values(assignments) ::= <<
static {
    <assignments; separator="\n">
}
>>

declaration(type, identifier) ::= <<
<type> <identifier>
>>

parameter(type, identifier) ::= <<
<type> <identifier>
>>

parallel(loads, others, stores) ::=<<
<loads; separator="\n">
<others; separator="\n">
<stores; separator="\n">
>>

parallel_load(type, identifier) ::= <<
<type> _ld_<identifier> = <identifier>;
>>

parallel_store(identifier, val) ::= <<
<identifier> = <val>;
>>

assignment(iterationConstruct, identifier, val) ::= <<
<iterationConstruct; separator="\n">
<identifier> = <val>;
>>

assignments(assignments) ::= <<
<assignments; separator="\n">
>>

nondeterminism(identifier, set) ::= <<
<identifier> = <set>.nondeterminism();
>>

void() ::= <<
void
>>

type(type) ::= <<
<type>
>>

couple_type(leftType, rightType) ::= <<
BCouple\<<leftType>, <rightType>\>
>>

set_type(type) ::=<<
BSet\<<type>\>
>>

relation_type(leftType, rightType) ::=<<
BRelation\<<leftType>, <rightType>\>
>>

import_type(type) ::= <<
import de.hhu.stups.btypes.<type>;
>>


interval(arg1, arg2) ::= <<
BSet.range(<arg1>,<arg2>)
>>

couple_create(arg1, arg2) ::= <<
new BCouple\<>(<arg1>, <arg2>)
>>


binary(arg1,operator,arg2) ::= <<
<arg1>.<operator>(<arg2>)
>>

unary(operator, obj, args) ::= <<
<obj>.<operator>(<args; separator=", ">)
>>

select(iterationConstruct, predicate, then) ::= <<
<iterationConstruct; separator="\n">
if((<predicate>).booleanValue()) {
    <then>
} else {
    throw new RuntimeException("Invocation of the operation is not possible");
}
>>

if(iterationConstruct, predicate, then, else1) ::= <<
<iterationConstruct; separator="\n">
if((<predicate>).booleanValue()) {
    <then>
} <else1; separator=" ">
>>

elseif(predicate, then) ::= <<
else if((<predicate>).booleanValue()) {
    <then>
}
>>

else(then) ::= <<
else {
    <then>
}
>>

choice(len, then, choice1) ::= <<
int index = (int) Math.floor(Math.random() * <len>);
if(index == 0) {
    <then>
} <choice1; separator=" ">
>>


choice1(counter, then) ::= <<
else if(index == <counter>) {
    <then>
}
>>

choice2(then) ::= <<
else {
    <then>
}
>>

any(type, identifier, set, body, index) ::= <<
for(int _<index>_i = 0; _<index>_i \< <set>.size(); _<index>_i++) {
    <type> <identifier> = (<type>) <set>.toArray()[_<index>_i];
    <body>
}
>>

any_body(predicate, body) ::= <<
if(<predicate>.booleanValue()) {
    <body>
    break;
}
>>

while(iterationConstruct1, iterationConstruct2, predicate, then) ::= <<
<iterationConstruct1; separator="\n">
while((<predicate>).booleanValue()) {
    <then>
    <iterationConstruct2; separator="\n">
}
>>

var(locals, body) ::=<<
<locals; separator="\n">
<body>
>>

boolean_val(val) ::= <<
<if(val)>new BBoolean(true)<else>new BBoolean(false)<endif>
>>

identifier(identifier, rhsOnLhs) ::= <<
<if(rhsOnLhs)>_ld_<identifier><else><identifier><endif>
>>

number(number, useBigInteger) ::= <<
<if(useBigInteger)>new BInteger("<number>")<else>new BInteger(<number>)<endif>
>>

operation_call_with_assignment(var, machine, function, args, this) ::= <<
<var> = <operation_call_without_assignment(machine, function, args, this)>
>>

operation_call_without_assignment(machine, function, args, this) ::= <<
<if(this)>this.<else>this.<machine>.<endif><function>(<args; separator=",">);
>>

