keywords() ::= <<
>>


machine(imports, machine, includes, enums, sets, initialization, operations, addition) ::= <<
<imports; separator="\n">

class <machine>:

    <includes; separator="\n">

    <enums; separator="\n\n">

    <sets; separator="\n">

    <initialization>

    <operations; separator="\n\n">

    <addition>
>>

initialization(body, machines) ::= <<
def __init__(self):
    <machines : {m | <include_initialization(m)>}; separator="\n">
    <body>
>>

include_initialization(machine) ::= <<
__<machine> = <machine>()
>>

method() ::= <<
>>

operation(operationName, parameters, locals, body, return) ::= <<
def <operationName>(self<parameters : {par |, <par>}>):
    <locals; separator="\n">
    <body>
    <return>
>>

return(identifier) ::= <<
return <identifier>
>>

no_return() ::=<<
>>

set_declaration(identifier, type, enums) ::= <<
__<identifier> = <set_enumeration(enums, false)>
>>

set_enumeration(enums, isRelation) ::= <<
<if(isRelation)>BRelation<else>BSet<endif>(<enums; separator=", ">)
>>

seq_enumeration(type, elements) ::= <<
>>

enum_call(class, identifier) ::= <<
<class>.<identifier>
>>

set_enum_declaration(name,enums) ::= <<
<name> = Enum(<enums; separator=", ">)
>>

include_declaration(type, identifier) ::= <<
__<declaration(identifier)> = <type>()
>>

global_declaration() ::= <<
>>

local_declaration(identifier) ::= <<
<declaration(identifier)> = None
>>

declaration(identifier) ::= <<
<identifier>
>>


constant() ::= <<
>>

values() ::= <<
>>

constant_declaration(type, identifier) ::= <<
<type> <identifier>
>>

constant_initialization(iterationConstruct, identifier, val) ::= <<
<iterationConstruct; separator="\n">
__<identifier> = <val>
>>


parameter(identifier) ::= <<
<identifier>
>>

parallel(loads, others) ::=<<
<loads; separator="\n">
<others; separator="\n">
>>

parallel_load(type, identifier) ::= <<
_ld_<identifier> = <identifier>
>>

assignments(assignments) ::= <<
<assignments; separator="\n">
>>

assignment(identifier, val) ::= <<
<identifier> = <val>
>>

void() ::= <<
>>

type() ::= <<
>>

tuple_type() ::=<<
>>

set_type() ::= <<
>>

relation_type() ::= <<
>>

import_type(type) ::= <<
import <type>
>>


interval(arg1, arg2) ::= <<
BSet.range(<arg1>,<arg2>)
>>

tuple_create(arg1, arg2) ::= <<
BTuple(<arg1>, <arg2>)
>>


binary(arg1,operator,arg2) ::= <<
<arg1>.<operator>(<arg2>)
>>

unary(operator, obj, args) ::= <<
<obj>.<operator>(<args; separator=", ">)
>>

select(predicate, then) ::= <<
if <predicate>.booleanValue():
    <then>
else:
    raise Error("Invocation of the operation is not possible")
>>

if(predicate, then, else1) ::= <<
if <predicate>.booleanValue():
    <then>
<else1; separator=" ">
>>

elseif(predicate, then) ::= <<
else if <predicate>.booleanValue():
    <then>
>>

else(then) ::= <<
else:
    <then>
>>

while(predicate, then) ::= <<
while <predicate>.booleanValue():
    <then>
>>

var(locals, body) ::=<<
<locals; separator="\n">
<body>
>>

boolean_val(val) ::= <<
<if(val)>BBoolean(true)<else>BBoolean(false)<endif>
>>

identifier(identifier, isPrivate) ::= <<
<if(!isPrivate)><identifier><else>self.__<identifier><endif>
>>

number(number) ::= <<
BInteger(<number>)
>>

operation_call_with_assignment_one_parameter(var, machine, function, args, this) ::= <<
<var> = <operation_call_without_assignment(machine, function, args, this)>
>>

operation_call_without_assignment(machine, function, args, this) ::= <<
<if(this)>self.__<else><machine>.<endif><function>(<args; separator=",">)
>>
